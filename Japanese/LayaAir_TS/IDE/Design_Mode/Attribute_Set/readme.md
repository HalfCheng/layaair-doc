#属性設定器

プロパティ設定器は、現在選択されているコンポーネントのプロパティを確認して編集します。シーンエディタまたは階層マネージャでコンポーネントを選択すると、クエリと編集のために属性設定器にコンポーネントの属性が表示されます。

属性設定器パネルは、図1に示すように、上から下までは、コンポーネントまたはノード名、**共通**属性、**常用**属性、**幅の高さと位置**を選択します**回転と拡大縮小**を選択します**その他**など。



 ![imgage](img/1.png)<br/>

（図1）プロパティパネルグループ



##1、`公用`属性の紹介

共通属性の中では通常`var`を選択します`name`を選択します`renderType`。図2-1に示すように。

![图2-1](img/2-1.png) <br /> (图2-1)



###1.1グローバル変数名の設定

`Var`：名声の一意のグローバル変数名は、プロジェクトコードの中でこの名前に基づいてこのコンポーネントを呼び出すために使用されます。

###1.2コンポーネント識別名を設定する

`name`コンポーネントの識別名です。階層マネージャで他のコンポーネントを区別するために使用されます。彼の父親の容器もこの名前でこのコンポーネントを見つけることができます。

###1.3コンポーネントのノード機能タイプを設定する

`renderType`ノード機能タイプは、mark、hit、unHit、render、instanceの5種類があります。

####1.3.1カバーに設定する

コンポーネントがセットされているとき`mask`を選択すると、このセットはカバーです。**親コンポーネント**maskカバー領域だけが見えます。効果は図2-2に示されています。



　　![动图2-2](img/2-2.gif)<br/>(図2-2)

####1.3.2クリックエリアと非クリックエリアを設定する

コンポーネントがセットされているとき`hit`をクリックします。コンポーネントがセットされているとき`unHit`を選択すると、このコンポーネントの親レベルのコンポーネントエリアは非クリックエリアです。**ポイントエリアhitのセットと非クリックエリアunHitのセットが重畳された場合**を選択します。非クリックエリアはunHitの方が優先度が高いです。図2-3に示すように、緑色の円がある非クリック領域（unHit）は、重ね合わせられた口の領域を含めてクリックできません。頭部の赤い半月のエリアだけがクリックできます。

　　![图2-3](img/2-3.png)<br/>(図2-3)

####1.1.3 Listのrenderに設定する

このコンポーネントがセットされると`render`リストリストリストListの作成のために、このコンポーネントを繰り返しレンダリングすることができます。リストを作るには、まず複数のコンポーネントを全部選んで、ctrl+Bでbox容器に設定する必要があります。また、この容器のrendertype属性をrenderに設定します。その後、ctrl+Bを使って、このboxをListに設定します。図2-4に示すように。

![动图2-4](img/2-4.gif)<br/>(図2-4)

####1.3.4単例のinstanceに設定する

このコンポーネントがセットされると`instance`このコンポーネントは一例のコンポーネントであり、複数のところで繰り返し使用される場合、一例のコンポーネントは一度だけ実装される。性能出費を節約する。



　　

##2、`常用`属性の紹介

通常の属性では、いくつかの操作が共通しています。ここでそれぞれ紹介します。

###2.1九宮格操作（sizGrid）

九宮格は、UIを4本の直線で9つに分離し、UIに対する引張操作があれば、中間領域は計算充填であり、他の領域は従来の設計を維持しており、UIがどのように引張されても変わらない。ゲーム開発でよく使われる機能です。

一般的な属性の`sizeGrid`属性は九宮格の設定です。属性入力欄の右側をクリックします。`grid`ボタンを押すと、九宮に入ることができます。図3-1に示すように。

![图3-1](img/3-1.png) <br / > (图3-1)


九宮格の設定を開くと、左は効果プレビューエリア、右は九宮格の可視化操作エリアとなります。マウスでドラッグして九宫枠の塗りつぶしエリアを変更して、プレビューの効果を得て、クリックして確認します。動作は図3−2に示すようになっている。

![动图3-2](img/3-2.gif)<br/>(図3-2)

###2.2皮膚設定（skin）

`skin`属性はセットの皮膚を変えることができます。属性欄に手動で皮膚の経路を入力する以外に、リソースマネージャから直接リソースをドラッグして`skin`属性入力欄で、肌の切り替えが速くできます。また、属性入力欄の右側をクリックします。`skin按钮`多くの資源の中から、現在の資源に速く位置づけられます。動作は図3-3に示すようになっています。

![动图3-3](img/3-3.gif)<br/>(図3-3)



###2.3肌状態カット（stateNum）

Button、checkBoxなどのコンポーネントの使用において、コンポーネントの皮膚資源は、図3-4に示すように、多状態縦配列からなる。

![图3-4](img/3-4.png) <br /> (图3-4)



####肌のカット方法：

三状態は皮膚の画像を縦方向に等比で分割する形で、図3-4に示すように、**上から下まで**順に`弹起或离开状态`肌、`经过状态`肌、`按下和选中`(*を押し続けます*)状態の皮膚、3状態はよくPCブラウザの中で使います。

モバイルデバイスでは、通常は2つの状態だけを採用しています。画像は縦方向で2つの部分に切断されています。上の部分は`弹起或离开状态状态`皮膚の下の部分は`经过和按下以及选中状态`（＊肌を押し続ける）。

写真をカットしないでください。どんな状態でも肌は一つしかないです。

####stateNumで指定した皮膚を何状態で切断しますか？

存在状態区分のコンポーネントに対して、stateNumの属性値は皮膚資源画像のカット方式を決定する。デフォルトのstateNum属性値は3です。つまりデフォルトでは3状態ボタンでカットし、等比は3つに分割されます。二状態ボタンであれば、stateNumの属性値を2に設定し、等比を2つにカットする必要があります。シングルボタンは1に設定し、カットは行いません。

ここで注意したいのは、ボタンの状態を指定するには、ボタンの肌に対応する必要があります。三状態のボタン肌なら、stateNumを2に設定し、カット後は図3-5に示すように誤っています。

![图3-5](img/3-5.png)<br/>(図3-5)



###2.4強力なruntime属性

`runtime`は、プロパティマネージャの非常に強力なコンポーネント拡張機能です。runtime属性に論理クラスを設定することにより、インスタンス時に作成されるのはコンポーネントの視認類ではなく、runtime属性で指定された論理クラスです。この属性には論理クラスの全パスを指定する必要があります。例えば「game.user.player」です。



###2.5可視色設定

カラーの属性設定の場合は、手動で色値を入力しても良いし、右側の色設定ボタンをクリックして、色設定パネルに色を指定してから、パネル外の任意の領域をクリックして、図3-6に示すように可視化色の設定が完了します。

![动图3-6](img/3-6.gif) <br />（动图3-6）



###2.6数字のモップ調整

属性値が数字の場合、入力枠の端にドラッグ＆ドロップ調整パネルがあります。多くの開発者はこの小技術に気づかず、マウスの左ボタンで調整パネルをクリックし、上にドラッグしたり、下にドラッグしたりすれば、数字を微調整できます。シーンエディタの対応するコンポーネントも瞬時に可視化が変化します。図3-7に示すように。

![动图3-7](img/3-7.gif)<br/>(図3-7)

### 



##3、幅の高さと位置の属性

幅の高さと位置の属性はUI制作において重要な役割を果たしている。位置およびUI画面の調整を主に行う（図4）。

![图片1.png](img/4.png)<br/>(図4)

###3.1 x、y属性

xとy属性は、シーンエディタにおけるコンポーネントのxとy軸座標である。

シーンエディタの左上が原点です。`（0, 0）`。 原点を中心にx軸を右に伸ばして正座標として増加し、y軸を下にして正座標として増加します。

はい、`场景编辑器`でセットを選択し、マウスを押してxとy軸の位置を変更したり、属性入力ボックスに固定値を設定したりできます。



###3.2 width、heightの幅と高属性

コンポーネントの大きさを変えないと、コンポーネントの幅の高さは自動的に計算されますが、プロパティパネルには表示されません。制約ボックスまたは固定値設定によってコンポーネントをスケーリングしてリセットすると、幅の高い属性が表示されます。また、数値のドラッグ操作も可能です。

任意のコンポーネントを選択しない場合、現在の幅はページ幅の高さになります。

*Tips：一部のコンポーネントは、制約ボックスのサイズを変更するだけで、実際のコンポーネントは拡大されませんが、マウスクリック領域は、例えばCheckBoxのような制約ボックスのサイズに縮小されます。*



###3.3 UI適応属性

`left、right、top、bottom`4つの属性は、主にコンポーネントとページエッジ距離位置との整合に用いられる。

`centerX、centerY`二つの属性は主にコンポーネントがページの中心位置にフィットするために使用されます。

ゲーム開発においては、すべての画面解像度をすべて考慮することはできません。高解像度、低解像度などがあります。ゲーム項目コードにフルスクリーンを使用すれば、コンポーネントはまた位置を固定し、異なる解像度の画面下でUIコンポーネントのビットずれを引き起こす。私たちは以下のように調整する必要があります。

####3.3.1余白位置が似合う

**設計目標**ゲームの右上に顔写真を置き、常に画面の上端と右端の50 pxを維持します。

**誤った実現効果**:

ある画面解像度でコンポーネントのxとyに固定値を設定すると、図5-1の効果が現れます。設計目標と一致しない。

![图5-1](img/5-1.gif) <br />

（図5−1）はコンポーネントのxとyに固定値を設定する場合、画面解像度効果が異なります。

**効果を正しく実現する**:

`left、right、top、bottom`4つの属性はそれぞれ親容器の左端、右端、上端、下端に基づいている。したがって、異なる画面解像度での相同右効果を実現するには、rightとtopの属性値を設定し、50ピクセルに設定します。設定後の運転効果を図5-2に示します。

![动图5-2](img/5-2.gif)<br/>(図5-2)

**画面の余白の設定に適用されます。**:

ここで特に注意したいのは、`left、right、top、bottom`の属性効果は、親容器（ページ）の各エッジに基づいており、画面の各エッジではない。親容器（ページ）の解像度は必ずプロジェクトのLaya.init（）と同じ解像度で設定してください。同じ設定でないと図5-2の動作効果は実現できません。



####3.3.2余白の引張りが似合う

あるエッジに位置する適合作用に加えて、left、right、top、bottomの属性値を同時に設定し、異なる画面に応じてコンポーネントを引っ張り合わせることができます。例えば、私達はleft、right、top、bottomの属性値を全部100に設定して、運転後は図5-3に示すようにします。

![动图5-3](img/5-3.gif) <br > (动图5-3)


*Tips：引張り適切な余白の設定方式は、通常、九宮格と組み合わせて実現する必要がある。*



####3.3.3センターの位置は適切です。

センターはスクリーンの中間のゲームに基づいてLOGOを起動したり、メッセージボックスをポップアップしたりするのによく使われます。私たちはセンターX、センターYによる位置中央設定ができます。図6-1、6-2に示すように。

![图片1.png](img/6-1.png)<br />（图6-1）



![图片1.png](img/6-2.png)<br />（图6-2）







##4、回転とズームのプロパティ

回転とズームのプロパティは、ゲームUIにおいて、特にIDEがアニメーションを作る時によく使われます。

####4.1ブッシュポイントの修正

「軸点」：コンポーネントの回転または拡大縮小の中心点は、デフォルトではコンポーネントの原点になります。`（0,0）`ポイントの位置。

ピvotX、ピvotY、アンチョルX、アンチョーYの4つの属性は、軸軸の位置を変更するために使用されます。

ピvotX、ピvotYは、セットの軸軸の点XY座標の固定値を変えることで、軸の位置を変更します。

アンチョーX、アンチョーYは、X軸とY軸のセット幅または高い割合で軸点座標位置を算出し、図7に示すように、幅と高さの50%で算出された座標が中心点座標位置となります。

![图7](img/7.png)<br />（图7）


**Tips**:*アンカーポイントを通過することは、非常に素早く軸軸をセットすることができます。しかし、アンカー方式はUIコンポーネントに対してのみ軸点を設定することができ、GraphicsコンポーネントやSpriteなどの2 Dベースコンポーネントの軸軸点は設定のみ可能である。`pivotX与pivotY`の方式で実現します。*

####4.2傾斜角度を修正する

skwax、skwayは、軸軸点を中心に水平・垂直角度の傾斜を行い、属性値効果を図8に示すように修正します。

![动图8](img/8.gif)<br />（动图8） 







####4.3コンポーネントのサイズ変更

scaleX、scaleYは、軸軸点を中心に水平、垂直の大きさでスケーリングされます。

デフォルトは1で、拡大縮小しません。正の値が大きいほど、サイズが大きくなります。

0にズームします。見えません。

`-1`を選択します**鏡像**効果は、図9に示すようになります。負の値が大きいほど、鏡像後のサイズは大きくなります。

![动图8](img/9.gif)<br/>(図9)

**Tips**:*中心に軸があれば、元の位置に鏡像ができます。例えば、キャラクターの二つの方向は同じ資源を使って実現できます。*



##5、その他の共通属性の紹介

LayaAirIDEは多くのコンポーネントを提供しています。それらはほとんどComponentコンポーネントのベースクラスに継承されているので、同じ他の共通の属性を持っています。ここでは主に他の属性の中の共通部分を紹介します。コンポーネント自体の特殊属性については、個々のコンポーネントを紹介する時に説明します。

共通の属性は以下のいくつかの種類があります。

関連属性を表示します。alpha、visible

キャッシュ関連属性：cacheAs、staticCache

マウス操作に関する属性：disabled、gray、httTestPrior、mouse Enbaled、mouse Through

label関連属性：label Align、label Colors、label Bold、labelFont、labelPadding、labelSize、label Stroke、label Stroke Color、stroke Color



###5.1関連属性の表示

表示に関する属性は比較的分かりやすく、表示オブジェクトはいずれもalphaとvisibleの属性を持っています。

`alpha`表示オブジェクトの透明度を調整します。数値は0-1の間、0はすべて透明で、1は不透明です。区間は半透明です。

**Tips**：表示オブジェクトのalphaの数値はどれぐらいであれ、マウスの傍受を加えると、マウスのイベントをサポートします。たとえアルファが0の場合でも、マウスのイベントが発生します。

`visible`コントロールコンポーネントの表示かどうか、この属性はブール値で、デフォルトはtrueで、正常に表示されます。falseの値は、コンポーネントが表示されません。マウスイベントは効果がありません。

*Tips：visibleがfalseの場合は表示されないということは、ブラウザで実行しても表示されないことを意味し、IDEでfalseに設定するとすぐに隠し変化が発生しません。*



###5.2キャッシュ関連属性

キャッシュの最適化に関する属性については、cache As、staticCacheは、単一のコンポーネントではなく、常に変化しない複雑なページを使用することを提案します。



**ゲーム中に大量のUIがあり、一つのUIには複数のノードがあり、変化が小さい場合は、cacheAsを使用することを推奨します。**

例えば、LayaAirIDEソフトウェアを使っていますが、ソフトウェアの多くのパネル、例えば属性設定器、資源管理器、プロジェクトマネージャなど、それらのアイデアの対象は多いですが、頻繁に変更されていないので、cacheAsを使ってキャッシュして、レンダリング効率を高めました。



**常に変化する複雑なUIについては、UIを2つの層に分割し、変化が少ない層にcacheAsを使用し、常に変化する層は使用しない。**例えば「カウントダウン」表示のUIがありますが、カウントダウンの部分と他の部分に分けてcacheAsを行い、カウントダウンの部分はcacheAsを行わないようにしてもいいです。



開発時にcacheAsを使うと、誤った理解とキャッシュメカニズムの使用はかえって性能を低下させます。以下は二つの主要な属性の詳細説明です。

**cacheAs:**

キャッシュコンポーネントは、静止画としてキャッシュされているかどうか、合理的な役割を果たすことができます。「none」と「normal」と「bitmap」の3つの値があります。

**「noneオプション」：**キャッシュを一切しないことを表す。

**「normalオプション」：**

canvasモードではキャンバスキャッシュを行います。複数のサブオブジェクトからなるUIをビットマップにキャッシュするのに相当します。各フレームをレンダリングする時は、キャッシュされたビットマップだけをレンダリングします。すべてのサブオブジェクトを一度レンダリングするのではなく、レンダリングオーバーヘッドを節約し、性能を向上させます。

ウィbglモードでコマンドキャッシュを行います。サブオブジェクトのみをキャッシュしたプロセスとプログラムコマンド組織に相当します。ビットマップとしてキャッシュされていません。各フレームをレンダリングする時、サブオブジェクトを再び遍歴する必要はなく、直接サブオブジェクトを遍歴した階層に従ってグラフィックカードでレンダリングします。DRawcalを減少させません。メモリ損失を増加させません。レンダリング性能は中ぐらいです。

**Tips**:*cacheAsBitmap属性機能はcacheAs属性のnormalモードに相当し、cacheAs Bitmap属性は古いバージョンIDEに対応して保留されています。現在関連する需要があれば、cacheAsのnormalを使って設定することを提案します。*

**「bitmapオプション」**:

canvasモードでは依然としてキャンバスキャッシュです。

webglモードでは、複数のサブオブジェクトからなるUIをビットマップにキャッシュし、グラフィックカードに提出してレンダリングすることに相当し、DRawcalを低減し、レンダリング性能が最も高い。キャッシュされたビットマップはメモリオーバーヘッドの一部を追加し、キャッシュされたビットマップが大きいほどメモリオーバーヘッドが大きくなります。キャッシュビットマップサイズは2048を超えてはいけません。このモードは継続的に再描画するとCPUのオーバーヘッドが増加します。

**Tips**＊cacheAsが「normal」と「bitmap」を選択すると、サブオブジェクトが変化し、自動的にキャッシュが再起動され、同時に手動でreCacheメソッドを呼び出してキャッシュを更新することもできます。＊



**staticCache：**

cacheAsが「none」でない場合にこの値が有効です。staticCache=trueの場合、サブオブジェクトが変化しても自動的にキャッシュが更新されません。ReCacheメソッドを呼び出して手動で更新するしかありません。

例えば、いくつかのデータが多いUIは、UIが開いてデータを読み出すと、UI表示を更新し続ける可能性があるので、データが読み終わったら、reCache方法で一気にデータを読み取り、更新するようにstaticCacheを設定しても良い。

具体的な例とデータ分析は「技術文書―2 D階段編―cacheAs性能最適化」を参照してください。



###5.3マウス操作に関する属性

マウス操作に関する属性説明とプレゼンテーションの効果は以下の通りです。

𞓜**その他の属性**𞓜**機能説明**𞓜
|------------------------------------|
マウスのイベントを受け入れるかどうか。デフォルトはfalseで、マウスイベントを傍受すると、自動的に本オブジェクトと親ノードの属性mouse Enbaleの値がtrueに設定されます（親ノードが手動でfalseに設定されている場合は変更されません）。𞓜
|disabled𞓜は無効かどうか、無効にして灰色になり、マウスイベントを受信しません。𞓜
124 grayは灰になっていますか？灰になってもマウスのイベントを受けられます。𞓜

![动图10](img/10.gif)<br />（动图10） 


**mouse Through:**

モジュールmouse Enbaled=trueマウスが使用可能な場合、透過可能ですか？デフォルトの値はfalseです。trueに設定すると、空白の領域をクリックして透過し、自分だけに有効です。

**hitTestPrior：**

自分を優先的にチェックするかどうか。デフォルトはfalseで、マウス衝突検出は優先的にサブオブジェクトを検出し、親オブジェクトに泡を立てます。hitestPrior=trueマウスの衝突が優先的に本オブジェクトを検出すると、本オブジェクトがヒットした後、さらにサブオブジェクトを検出します。既知の大きさの容器（特に根容器）に対しては、デフォルトではfalseとして設定されています。この値をtrueとして設定すると、ノード衝突を低減し、性能を向上させます。

例えば、複雑なBoxでは、内部に複数のサブオブジェクトがありますが、Box自体をマウスでモニターする必要がありますので、hitTestPriorをtrueとして設定できます。マウスをクリックする時は、サブオブジェクトからBoxに泡を噴き出すプロセスを省き、直接マウスイベントをトリガし、性能を向上させます。

*Tips：UIのViewコンポーネントhitTestPriorのデフォルト属性値はtrueです。*



###5.4 label関連属性

多くのコンポーネントの内部には、Button、CheckBox、Tabなどのlabelラベルが含まれている。これらの他の属性にも同じラベル属性の設定があります。機能説明は下表をご覧ください。

𞓜**属性名**𞓜**機能説明**𞓜
|----------------------------------------|
|labelAlignラベル配置モードは、デフォルトでは中央揃えです。注：CheckBoxで無効になります。
ラベルの各状態のテキスト色を表す。フォーマット：「up Color、overColor、downColor、disable Color」。デフォルトは「青、緑」です。𞓜
|label Bold|はラベルのテキストラベルが太字であるかどうかを表しています。𞓜
|Label Font|はテキストラベルのフォント名を表し、文字列で表します。IDEで選択可能です。𞓜
|labelPadding|はテキストラベルの余白を表します。書式：「上余白、右余白、下余白、左余白」。𞓜
|LabelSize 124;はテキストラベルのフォントサイズを表します。𞓜
|label Stroke|文字のエッジ幅（ピクセル単位）。デフォルトの値は0で、トレースしないことを表します。𞓜
|label StrokeColorの文字の端の色を文字列で表現します。標準値は「#000000″（黒）;|
|strook Color|は、それぞれの状態におけるエッジの色を表します。フォーマット：「up Color、overColor、downColor、disable Color」。𞓜

*Tips：上記の表の属性はlabelコンポーネントにLabelを含まないが、作用は完全に一致している。`labelAlign`属性とlabelコンポーネントの`align`属性が完全に一致します。*