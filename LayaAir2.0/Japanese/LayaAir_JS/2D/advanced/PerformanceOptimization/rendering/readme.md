#グラフィックレンダリング性能

### **一、スピリットの最適化**

1.必要でない層の入れ子をできるだけ減らし、Spriteの数を減らす。

2.非可視領域のオブジェクトはできるだけ表示リストから削除またはvisible=falseを設定します。

3.容器内に大量の静的な内容や頻繁に変化しない内容（例えばボタン）については、容器全体にcacheAs属性を設定することができ、Spriteの数を大幅に減少させ、性能を著しく向上させることができる。ダイナミックコンテンツがある場合は、静止コンテンツのみをキャッシュするために、静的コンテンツとは別にしたほうがいいです。

4.Panel内では、パンエリア外の直接サブオブジェクト（サブオブジェクトのサブオブジェクトは判断できない）に対してレンダリング処理を行いますが、パンエリアを超えたサブオブジェクトは消費が発生しません。

​

### **二、最適化DrawCall**

1.複雑な静的内容にcacheAsを設定し、DrawCallを大量に減らすことができ、cacheAsを上手に使うことがゲーム最適化の鍵です。

2.できるだけ同じ図集の写真のレンダリング順序を確保し、異なる画集が交差してレンダリングされると、DrawCallの数を増加させる。

3.できるだけ同じパネルのすべての資源を一つの図集で確保し、提出ロットを減らすことができる。

​

### **三、Canvasを最適化する**

Canvas最適化に際しては、以下の場合にcacheAsを使用しないように注意する必要があります。

1.オブジェクトは非常に簡単で、例えば、1文字または1つの写真で、cacheAs="bitmap"を設定すると、性能を向上させるだけでなく、性能を失うことになります。
2.容器内には常に変化する内容があります。例えば、容器内にアニメーションやカウントダウンがあります。この容器にcacheAs="bitmap"を設定すると、性能が損なわれます。

Canvas統計情報の最初の値を見ることで、キャッシュを更新しているかどうかを判断することができます。

### **四、cacheAsについて**

cacheAsを設定すると、表示オブジェクトを静止画としてキャッシュし、cacheAsを行うと、サブオブジェクトが変化し、自動的にキャッシュし直し、同時に手動でReCacheメソッドを呼び出してキャッシュを更新することもできます。常に変化しない複雑な内容を、静止画としてキャッシュし、レンダリング性能を大幅に向上させることを提案します。cacheAsには「none」があり、「normal」と「bitmap」の3つの値があります。

1.デフォルトは「none」で、キャッシュは一切しません。
2.値が「normal」の場合、Canvasで画布キャッシュを行い、webglモードでコマンドキャッシュを行います。
3.値が「bitmap」の場合、Canvasでは依然としてキャンバスキャッシュが行われ、webGLモードではレンダーTargetキャッシュが使用されます。ここで注意すべきことは、webGLにおけるrendeTargetキャッシュモードは2048サイズの制限があり、2048を超えるとメモリオーバーヘッドが追加的に増加することである。また、継続的に描き直す場合は出費も大きいですが、ドラックコールを減らし、レンダリング性能が最高です。webGLの命令キャッシュモードは、ノード巡回およびコマンド組織を減少させるだけで、drawcalを減少させません。性能は中ぐらいです。

cacheAsを設定すると、キャッシュの自動更新を阻止するためにstaticCache=trueを設定することができ、同時に手動でreCacheメソッドを呼び出してキャッシュを更新することができます。

cacheAsは主に両方を通じて性能を向上させる。一つは、ノードエルゴードと頂点計算を低減すること、二つはドラックCallを低減することである。効率的なcacheAsは、エンジンの最適化機能の利器となります。

次の例では、10,000個のテキストを描画します。


```javascript

Laya.init(550,400,Laya.WebGL);
Laya.Stat.show();
var textBox = new Laya.Sprite();
for(var i=0;i<10000;i++){
    txt=new Text();
    txt.text=(Math.random()*100).toFixed(0);
    txt.color="#CCCCCC";
    txt.x=Math.random()*550;
    txt.y=Math.random()*400;
    textBox.addChild(txt);
}
Laya.stage.addChild(textBox);
```


以下は筆者のコンピュータ上の運行時のスクリーンショットで、FPSは52上下に安定しています。

![1](img/1.png)<br/>

（図1）

文字がある容器をcacheAsとして設定した後、以下の例に示すように、性能が大きく向上し、FPSは60フレームに達した。


```javascript

//...省略其他代码...
var textBox=new Laya.Sprite();
textBox.cacheAs="bitmap";
//...省略其他代码...
```


![2](img/2.png)<br/>

（図2）

### **五、文字の境界線**

実行時には、トレースがないテキストよりも一度多く描画命令を呼び出すテキストが設定されています。この場合、テキストはCPUの使用量とテキストの数に比例する。したがって、代替案をできるだけ使用して、同じ需要を達成します。

・ほとんど変動しないテキストの内容については、cacheAsを使用して性能消費を低減し、「グラフィカルレンダリング性能-cachAsについて」を参照してください。

・内容は常に変動しますが、使用する文字の数が少ないテキスト領域では、ビットマップフォントを選択できます。

### **六、テキストレイアウトをスキップして直接レンダリングする**

多くのテキストは複雑なレイアウトを必要とせず、簡単に1行の文字だけを表示します。この要求に応えるために、Textが提供するchange Textという方法は直接レイアウトをスキップすることができます。


```javascript

var txt=new Laya.Text();
txt.text="text";
Laya.stage.addChild(txt);
//后面只是更新文字内容，使用changeText能提高性能
txt.changeText("text changed.");
```


Text.changeTextは直接図形描画命令中のテキスト描画の最後の命令を修正します。このような前の図形描画命令が依然として存在する行為は、changeTextが以下の状況にのみ使用されることになります。

・テキストは常に1行だけです。

・テキストのスタイルは常に変わりません（色、太さ、斜体、配置など）。

それでも、実際のプログラミングではよく使われています。