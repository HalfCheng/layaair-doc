#微信のゲームは実戦に分けられます。

>author：charley

いくつかの大型ゲームにとって、微信のミニゲームの4 Mの初期パッケージははるかに足りないです。JSだけで4 Mを超えるので、2.1のミニゲームのベースライブラリが発売される前に、絶えず機能を切り続けるしかないです。JSは4 Mより小さいです。（新米があったら分かりません。なぜですか？まず基礎を調べてから本文を見に行きます。）ミニゲームの基本ライブラリは2.1バージョンからパック形式でアップロードされたパッケージを8 Mに拡大してサポートしていますが、どうやって分割しますか？

**本編では、パックの仕方だけでなく、ミニゲームについても、パックの過程でよくある問題に対して、実例のDEMOを通じて、関連した紹介を行い、開発者にミニゲームの包み方と注意事項を理解するように助けます。**



###一、本当に分けますか？

もしパッケージの流れやwindowドメインにあまり詳しくない開発者に対しては、パッケージを分けて問題に直面します。また、私たちはカバンを分ける前に、自分のプロジェクトを分析しなければならないですが、本当にデバッグの需要がありますか？実は今の大多数の製品にとって、カバンを分けずにオンラインでミニゲームの製品を作ることができます。

####1、UIを使ったことがありますか？それとも分離モードですか？

LayaAirエンジンの開発者で、UIはLayaAirIDEで作られることが多い。

F 9のUIモードオプションおよびプロジェクトマネージャ、各UIページを右クリックしてデフォルト属性を設定する場合のエクスポートタイプオプションは、埋め込みモード、ローディングモード、分離モードの3つのオプションが見られます。

![图1](img/1.png) 


**デフォルトは埋め込みモードです。**このようなモードでは、UIのページをエクスポートすると、設定情報などのコンテンツがプロジェクトのコードファイルとして出力されます。最終的にミニゲームとしてリリースされるのは、jsファイルです。そのため、いくつかの貴重なミニゲームのローカルパッケージのボリュームを占用しました。だから**これにより、ゲームのパッケージサイズが減少し、UIを出力するモードをロードモードまたは分離モードに変更することができます。**この2つのモードはいずれも、ページ構成情報などをJsonファイルにエクスポートします。jsonファイルは、ローカルパケット空間を占有することなく、URLを通じて遠隔的に動的にロードして使用できます。

>**Tips:**
>
>1、ロードモードと分離モードの違いは、ロードモードは全てのUIページを一つのjsonファイルにエクスポートし、分離モードは各UIページを一つの独立したjsonに導出することである。
>
>2、ロードモードと分離モードはJsonを導出するため、コードを書いてロードしてから使用することができるので注意してください。埋め込みモードは必要ありません。

つまり、ロードモードと分離モードは、パッケージJSのサイズを減らすことができる。このような方法で解決できれば、パケットで解決する必要がないかもしれません。具体的な状況はプロジェクトによって決められます。

#### **2、不要なJSコードを削除する**

パケットが分割されていない場合、HTMLページで参照されているJSは、プロジェクト内でjsに対して別の引用がない限り、jsファイルに統合されます。もしそうでなければ、HTMLページにない他のjsは直接に削除できます。例えば、使っていないエンジンライブラリjsがあります。プロジェクトディレクトリの下で直接削除してもいいです。このように発表する時はもう現れません。

####3、圧縮と混淆

圧縮混淆後のjsコードを通じて、パッケージ体験が著しく減少しました。JSが4 Mを超えていないなら、分けなくてもいいです。リソースなどのコンテンツは、URLを使って動的にロードできます。最初にロードすると、物理キャッシュ内に存在します。50 Mを超えない常用キャッシュ内容です。次のオープンにはロードする必要がありません。



###二、ミニゲームを勉強します。

実戦で分包する前に、公式文書を見たことがないので、必ずよく見てください。これは非常に有用です。いくら理解しても、まず文書の要点を理解してから、より良い理解ができます。リンクは下記の通りです。まず見てから後のステップを進めてください。

[https://developers.weixin.qq.com/minigame/dev/tutorial/base/subpackages.html](https://developers.weixin.qq.com/minigame/dev/tutorial/base/subpackages.html)



###三、微信のミニゲームの公式パッケージ方式

多くの開発者が公式の下請け文書を見ましたが、ここで重要なのを拾ってから渡ります。

####1、game.jsonに、パケット名とパケットパスを分けるフィールドを配置する。


```json

{
  ...
  "subpackages": [
    {
      "name": "stage1",
      "root": "stage1/" // 可以指定一个目录，目录根目录下的 game.js 会作为入口文件，目录下所有资源将会统一打包
    }, {
      "name": "stage2",
      "root": "stage2.js" // 也可以指定一个 JS 文件
    }
  ]
  ...
}
```


subpackagesには、複数のnameとrootがあります。各グループは一つのパックを表します。一つのパックは、4 Mを超えてはいけません。全部のゲームの初期パッケージは8 Mを超えてはいけません。

まず分包配置の構造と注釈説明を見て、一応理解してください。まだ分からないなら、後の実戦的な配置に合わせて理解してもいいです。

####2、ミニゲームの公式パッケージにサンプルコードをロードする

ミニゲーム公式サイトが提供されました。[wx.loadSubpackage()](https://developers.weixin.qq.com/minigame/dev/document/subpackages/wx.loadSubpackage.html)APIはパケットのダウンロードをトリガし、wx.loadSubpackageを呼び出した後、パケットのダウンロードとローディングをトリガし、ロードが完了したら、wx.loadSubpackageのsuccessフィードバックによってローディング完了を通知します。サンプルコードは以下の通りです。


```javascript

const loadTask = wx.loadSubpackage({
  name: 'stage1', // name 可以填 name 或者 root
  success: function(res) {
    // 分包加载成功后通过 success 回调
  },
  fail: function(res) {
    // 分包加载失败通过 fail 回调
  }
})
```


ロード成功と同時に、wx.loadSubpackageは一つ戻ります。[LoadSubpackageTask](https://developers.weixin.qq.com/minigame/dev/document/subpackages/LoadSubpackageTask.html)LoadSubpackage Taskを通じて現在のダウンロード進捗を取得することができます。サンプルコードは以下の通りです。


```javascript

loadTask.onProgressUpdate(res => {
  console.log('下载进度', res.progress)
  console.log('已经下载的数据长度', res.totalBytesWritten)
  console.log('预期需要下载的数据总长度', res.totalBytesExpectedToWrite)
})
```


この文書は主にパック方法と開発者がよく出会うwindowドメインによるパッケージ分けの問題を説明します。ダウンロードの進捗状況は分かりやすく、開発者のフィードバックに関する問題がないので、実戦コードでは言及していません。もしこの問題があったら、コミュニティで提出してもいいです。



###四、ダウンロード例項目

私は皆さんのために簡単なサンプルを二つ用意しました。ダウンロードして解凍した後、default Demoディレクトリの下に、分割前のサンプル項目があります。subPackage Demoカタログの下に、分割後のサンプル項目があります。開発者はこの文書を読みながら、分割前と分割後の項目で差を比較して、ゲームの区切りを理解することができます。

ダウンロード先:[https://github.com/layabox/layaair-doc/raw/master/project/JS/JS_subPackage_Demo.zip](https://github.com/layabox/layaair-doc/raw/master/project/JS/JS_subPackage_Demo.zip)



###五、実戦でポイントを分けます。

####1、WeChat開発者ツールとリリース項目の注意

実戦パックの第一歩は、必ずWeChat開発者ツールでミニゲームを作成してください。パッケージを分けたら、ミニゲームのローディングシステムが採用されていますので、ブラウザーでは実行できなくなります。全体のデバッグプロセスはWeChat開発者のツールで全部完了します。そこで、皆さんのために準備したサンプルをダウンロードして、先にdefault Demoのカタログの例を開いて、ミニゲームのバージョンを発表します。基礎デバッグの流れを走り通す。

>Tips：ここで注意したいのは、ダウンロードの項目は、すでに発表されていますので、デフォルトで記録されているのは以前発表されたディレクトリです。

####2、ベースライブラリバージョン

マイクロクレジット開発者のツールのデバッグベースライブラリのバージョンを確認してください。そうでないと、本文の操作に従って、デバッグのバージョンがサポートされていないので、デバッグに問題が発生します。

開発者ツールは1.02.1806120および以上のバージョンを使用します。

ベースライブラリは2..0および以上のバージョンを使用します。

この文書は2.2.0です。図1に示すように、

![图2](img/2.png) 


（図2）

####3、分割カタログの関連操作

#####game.jsonを修正します

パックを分ける前に、カタログを分けて企画し、game.jsonの中で表現します。

ここでは簡単にパッケージディレクトリbを設定します。まずdefault Demoのサンプル項目のgame.jsonを以下のコードに変更してもいいです。


```json

{
  "deviceOrientation": "landscape",
  "showStatusBar": false,
  "networkTimeout": {
    "request": 10000,
    "connectSocket": 10000,
    "uploadFile": 10000,
    "downloadFile": 10000
  },
  "subpackages": [
    {
      "name": "b",
      "root": "js/b/"
    }
  ]
}
```


小さなゲームのパッケージリストを設定してから計画します。私たちはパッケージディレクトリとファイルを作成しに行きます。

#####rootパスに注意

JSプロジェクトの`src`ディレクトリ下のコードがリリースされている場合、`bin/index.html`に引用があります。エンジンライブラリと一緒にcode.jsに統合されます。いません`bin/index.html`の引用は直接jsディレクトリにコピーされます。だから`root`の経路はjsを抜かさないでください。図3に示すように。

![图3](img/3.png) 


（図3）

#####要約しないコンパイル機能

JSプロジェクトをコンパイルする必要はありません。直接に小さなゲームをリリースすればいいです。もしうっかりしてコンパイルをしたら。index.の中を開けてみてください。分割されたjsが引用されていますか？引用されたら、必ず注釈してください。図4に示すように。

![图4](img/4.png) 


（図4）

index.で引用された都市はcode.jsに合併されるので、ちょうどパケットのコードを分けます。code.jsに合わせるのは嫌です。だから、コンパイルをしてチェックします。

#####game.jsを作成します

rootでは具体的なjsファイルを入り口として指定できますが、パッケージ内に複数のjsがあることを考慮して、この文書の例ではディレクトリのデフォルトのエントリgame.jsを採用しています。

jsプロジェクトはコンパイルが必要ではないので、直接に小さいゲームのプロジェクトディレクトリ内で作成すればいいです。本論文では`game.js`位置`src/b`ディレクトリの下で`b.js`同じレベルで、上の図3に示すように。

game.jsにサブパッケージjsパスを導入しました。以下の通りです。


```javascript

require('b.js');
```




####4、分包符号化を開始する

前のステップで分包ディレクトリと分包ファイルを作成したら、分包コードを開始できます。

まず原則として、分包を作ります。**メインパッケージとサブパッケージの論理的な関連性は、できるだけ少なければ良いです。**。

もちろん、開発者によっては、いくつかのメインパッケージとパケットの相互呼び出しの関連需要が必要になります。ですから、私が皆さんに用意した簡単な例では、元々は一つのメインバッグの中にあるロジックを部分的に取り出して分包に入れるということです。

例えばdefault Demoディレクトリの例項目の中の`showA`下請けに出す`b.js`ここです。このコードには、より強い二つのパッケージ関連があります。一つは、現在のページを破壊し、aUIページをステージに追加するロジックshouUIをメインパッケージにし、もう一つはマウスイベントを傍受するトリガ関数showBもメインパッケージにします。

分割されたb.jsコードは以下の通りです。


```javascript

//显示A页
function showA()
{
   showUI(aUI,UI)
   
    //监听按钮btnA的点击事件，触发后处理
    UI.btnA.on(Laya.Event.CLICK, this, showB);
}
```


コードが分離された後、メインパッケージ内でWeChatミニゲーム公式から提供されたパッケージのロードとコールバックの通知方法を忘れないでください。サンプル項目では、私たちは直接に図セットにロードされたコールバックにパケットをロードします。そしてロード成功後に出力します。`success`のロゴ、および関連するゲームロジックを処理します。もちろん処理しなくてもいいです。これはゲームのロジックです。書き方が多いので、深く入り込みません。サンプルコードは以下の通りです。


```javascript

//图集加载后回调
function onLoaded()
{
   showUI(aUI);
   
   const loadTask = wx.loadSubpackage({
        name: 'b', // name 可以填 name 或者 root
        success: function(res) {
            // 分包加载成功后通过 success 回调
            console.log("success");
            //监听按钮btnA的点击事件，触发后处理
             UI.btnA.on(Laya.Event.CLICK, this, showB);
        },
        fail: function(res) {
            // 分包加载失败通过 fail 回调
            console.log("fail");
        }
    })
    
}
```


この時、ゲーム公式のドキュメントによって、理論的には、パッケージ分けの流れはすでに終わっているはずです。ミニゲームコードをリリースして、WeChat開発者ツールで効果を見てみます。

意外ではないです。間違いがあります。文書を読み続けます。

####5、windowドメイン

ブラウザーの中で、デフォルトはすべてwindowドメインの中にあります。ミニゲームはそうではないので、複数のjsの間の呼び出しが問題になりますので、IDEが発表された時には、すべての項目jsをエンジンと一緒にcode.jsに統合して、今はパッケージを分ける方案がwindowドメインという問題に直面します。したがって、メインパッケージとパケットの呼び出しが必要です。まず、呼び出された関数や変数をwindowドメインに置く必要があります。そして使う時は前にもwindowというキーワードを持っていきます。例のプロジェクトを使って実戦体験を行います。



まず、カバンを分けて見ました。`b.js`で、メインパッケージのショーUI、aUI、UI、showBなどを使います。じゃ、私達のカバンの中で、まず彼らをwindow領域に置いて、次のようにします。具体的な実戦では、開発者は、パック前と分割後の2つの例示的な項目を比較することができる。


```javascript

//把需要被分包中使用的放到window域里
window.showB = showB;
window.showUI = showUI;
window.aUI = aUI;
window.UI = UI;
```


メインパックの中にもパックの関数が使われますので、分けて包むのも同じです。まず分けカバンに使われる方法をwindowドメインに追加します。そしてメインカバンの中のそれらを使います。すべてwindowのキーワードをつけます。修正後は下記のコードのようになります。


```javascript

// 显示A页
function showA()
{
    //放到window里的方法，取的时候也要用window取
   window.showUI(window.aUI,window.UI)


    //监听按钮btnA的点击事件，触发后处理
    window.UI.btnA.on(Laya.Event.CLICK, this, window.showB);
}

//其它包里要使用的方法，也必须放到window里
window.showA = showA;
```


もちろん、メインバッグの中でショーAを使うところも、ウィンドを追加します。具体的に使うのは大体こんな簡単です。windowドメインに対する理解を通じて。カバンを分けて問題を解決することができます。

###六、開発者の実戦提案

開発者はまず私が与えたサンプル項目を分けて試してもいいです。問題があれば、この文書を見てもいいです。そして、私が与えた二つの例示的な項目の違いを比べてもいいです。まずはWeChatで走ります。本当の理解は分包してから、自由な実戦ミニゲームを行います。問題があったら、コミュニティに問題を出してください。そして問題の中でデモのプロジェクトをアップロードしてください。グループの中で@管理人charleyがリンクを提供してくれます。

その後、開発者がカバンを分けていることに気づいたら、新しい問題に直面しています。



##この文章は賞賛します

本論文があなたのために役立つと思ったら、スキャンコードの作者への賞賛を歓迎します。激励は私たちがより多くの優れた文書を書くための動力です。

![wechatPay](../../../wechatPay.jpg)